#!/usr/bin/env node

/**
 * Script to check coverage thresholds independently from Bun's built-in threshold checking
 * This works around the known issue where using both coverage=true and coverageThreshold
 * in bun.toml causes Bun to always return exit code 1.
 */

import fs from 'fs';
import path from 'path';

// Define thresholds (these were previously in bun.toml)
const THRESHOLDS = {
  statements: 80,
  branches: 70,
  functions: 80,
  lines: 80
};

// Path to the coverage JSON file generated by c8
const COVERAGE_PATH = path.join(process.cwd(), 'coverage', 'coverage-final.json');

try {
  // Check if coverage file exists
  if (!fs.existsSync(COVERAGE_PATH)) {
    console.error('\x1b[31mError: Coverage file not found. Run tests with coverage first.\x1b[0m');
    process.exit(1);
  }

  // Read and parse the coverage data
  const coverageData = JSON.parse(fs.readFileSync(COVERAGE_PATH, 'utf8'));
  
  // Calculate overall coverage metrics
  let totalStatements = 0;
  let coveredStatements = 0;
  let totalBranches = 0;
  let coveredBranches = 0;
  let totalFunctions = 0;
  let coveredFunctions = 0;
  let totalLines = 0;
  let coveredLines = 0;

  // Process each file's coverage data
  Object.values(coverageData).forEach(file => {
    // Statements
    if (file.statementMap) {
      totalStatements += Object.keys(file.statementMap).length;
      coveredStatements += Object.values(file.s).filter(v => v > 0).length;
    }
    
    // Branches
    if (file.branchMap) {
      const branchArray = Object.values(file.b);
      totalBranches += branchArray.reduce((sum, arr) => sum + arr.length, 0);
      coveredBranches += branchArray.reduce((sum, arr) => sum + arr.filter(v => v > 0).length, 0);
    }
    
    // Functions
    if (file.fnMap) {
      totalFunctions += Object.keys(file.fnMap).length;
      coveredFunctions += Object.values(file.f).filter(v => v > 0).length;
    }
    
    // Lines
    if (file.lineMap || file.l) {
      const lineData = file.l || {};
      totalLines += Object.keys(lineData).length;
      coveredLines += Object.values(lineData).filter(v => v > 0).length;
    }
  });

  // Calculate percentages
  const statementCoverage = totalStatements ? (coveredStatements / totalStatements) * 100 : 0;
  const branchCoverage = totalBranches ? (coveredBranches / totalBranches) * 100 : 0;
  const functionCoverage = totalFunctions ? (coveredFunctions / totalFunctions) * 100 : 0;
  const lineCoverage = totalLines ? (coveredLines / totalLines) * 100 : 0;

  // Print coverage report
  console.log('\n\x1b[1mCoverage Threshold Check\x1b[0m');
  console.log('----------------------------------------');
  console.log(`Statements: ${statementCoverage.toFixed(2)}% (threshold: ${THRESHOLDS.statements}%)`);
  console.log(`Branches:    ${branchCoverage.toFixed(2)}% (threshold: ${THRESHOLDS.branches}%)`);
  console.log(`Functions:   ${functionCoverage.toFixed(2)}% (threshold: ${THRESHOLDS.functions}%)`);
  console.log(`Lines:       ${lineCoverage.toFixed(2)}% (threshold: ${THRESHOLDS.lines}%)`);
  console.log('----------------------------------------');

  // Check if any thresholds are not met
  const failedChecks = [];
  
  if (statementCoverage < THRESHOLDS.statements) {
    failedChecks.push(`Statement coverage (${statementCoverage.toFixed(2)}%) is below threshold (${THRESHOLDS.statements}%)`);
  }
  
  if (branchCoverage < THRESHOLDS.branches) {
    failedChecks.push(`Branch coverage (${branchCoverage.toFixed(2)}%) is below threshold (${THRESHOLDS.branches}%)`);
  }
  
  if (functionCoverage < THRESHOLDS.functions) {
    failedChecks.push(`Function coverage (${functionCoverage.toFixed(2)}%) is below threshold (${THRESHOLDS.functions}%)`);
  }
  
  if (lineCoverage < THRESHOLDS.lines) {
    failedChecks.push(`Line coverage (${lineCoverage.toFixed(2)}%) is below threshold (${THRESHOLDS.lines}%)`);
  }

  // Report any failures and exit with appropriate code
  if (failedChecks.length > 0) {
    console.error('\n\x1b[31mCoverage thresholds not met:\x1b[0m');
    failedChecks.forEach(msg => console.error(`\x1b[31m- ${msg}\x1b[0m`));
    process.exit(1);
  } else {
    console.log('\n\x1b[32mAll coverage thresholds met! âœ“\x1b[0m');
    process.exit(0);
  }

} catch (error) {
  console.error('\x1b[31mError processing coverage data:\x1b[0m', error);
  process.exit(1);
}
